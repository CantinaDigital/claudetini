# Test Fixture Projects

Last updated: 2026-02-17

---

## 1. Purpose

The test fixture projects are a set of 10 pre-built, self-contained project directories used for automated testing of Claudetini's core modules. Each fixture simulates a specific real-world project state -- from an empty repo with no roadmap, to a fully consolidated project with archived planning history. Together they provide comprehensive coverage of every project shape that Claudetini must handle.

The fixtures live at:

```
tests/fixtures/projects/
```

They are generated by the script `tests/fixtures/generate_fixtures.py` and consumed primarily by the end-to-end test suite at `tests/e2e/test_project_scenarios.py`. The core modules under test include `Project`, `RoadmapParser`, `ProjectPlanScanner`, `PlanConsolidator`, `GitUtils`, and `HealthScanner` (all from `src/core/`).

---

## 2. Manifest File

**Path:** `tests/fixtures/projects/manifest.json`

The manifest is a JSON file auto-generated by `generate_fixtures.py` that inventories every fixture. It contains a single top-level key `"fixtures"`, which is an array of objects with three fields each:

| Field | Type | Description |
|-------|------|-------------|
| `name` | string | Directory name of the fixture (e.g. `"01_empty_project"`) |
| `path` | string | Relative path from the repo root to the fixture directory |
| `description` | string | One-line docstring from the setup function that created the fixture |

**How it is used:**

- The `load_manifest()` helper in `tests/e2e/test_project_scenarios.py` reads this file to discover available fixtures at test time.
- If the manifest is missing, the E2E test suite skips all fixture-dependent tests and prints a message directing the developer to run the generator script.
- The manifest makes it possible for test tooling and CI to enumerate fixtures without hard-coding their names.

**Example entry:**

```json
{
  "name": "02_single_roadmap",
  "path": "./tests/fixtures/projects/02_single_roadmap",
  "description": "Clean project with one ROADMAP.md - ideal state."
}
```

---

## 3. Fixture Catalog

### 3.1 `01_empty_project`

**Description:** A freshly initialized git repository with nothing but a `README.md`. No roadmap, no `CLAUDE.md`, no source code.

**Project state it represents:** A brand-new project that has been `git init`-ed and has a single initial commit, but has not yet adopted any planning structure. This is the absolute minimum viable project.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Empty Project` stub |
| `.git/` | Initialized git repo with one commit |

**Tests that use this fixture:** `TestEmptyProject` in `test_project_scenarios.py`

- `test_project_loads` -- verifies `Project.from_path()` succeeds and sets the name correctly
- `test_no_roadmap_detected` -- verifies `project.has_roadmap()` returns `False`
- `test_git_is_clean` -- verifies `GitUtils.uncommitted_files()` returns an empty list
- `test_plan_scanner_returns_empty` -- verifies `ProjectPlanScanner.scan()` finds zero items

**Claudetini behavior tested:** Graceful handling of projects that have no planning artifacts at all. The app must not crash or show misleading data when roadmap, CLAUDE.md, and plan files are absent.

---

### 3.2 `02_single_roadmap`

**Description:** A clean project with exactly one `ROADMAP.md` at the project root -- the ideal, canonical state.

**Project state it represents:** A well-structured project that already follows the Claudetini convention of a single roadmap file. It has 3 milestones with 10 total items, 2 of which are complete (20% progress).

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Single Roadmap Project` |
| `CLAUDE.md` | `# Project Guide` with standard conventions note |
| `ROADMAP.md` | 3 milestones (Foundation, Features, Polish), 10 items, 2 done |
| `.git/` | Initialized git repo, clean working tree |

**Tests that use this fixture:** `TestSingleRoadmap` in `test_project_scenarios.py`

- `test_project_loads` -- verifies project loads with correct name
- `test_roadmap_detected` -- verifies `has_roadmap()` returns `True`
- `test_roadmap_path_correct` -- verifies the detected roadmap file is `ROADMAP.md`
- `test_progress_calculation` -- verifies 2/10 items done = 20%
- `test_no_consolidation_needed` -- verifies `PlanConsolidator.needs_consolidation()` returns `False`

**Claudetini behavior tested:** The happy path. Correct roadmap detection, accurate milestone parsing, correct progress percentage calculation, and confirmation that a single-source project does not trigger consolidation warnings.

---

### 3.3 `03_multiple_sources`

**Description:** A project with multiple conflicting planning files scattered across different locations.

**Project state it represents:** A messy project where planning information has accumulated in multiple places over time -- a common scenario that Claudetini's consolidation feature is designed to fix. The planning files contain overlapping but not identical task lists.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Multi-Source Project` |
| `CLAUDE.md` | Contains `claudetini:managed` section with embedded status |
| `ROADMAP.md` | Phase 1 with 3 items (1 done) |
| `.planning/ROADMAP.md` | Master Roadmap with Phase 1 (3 items, 2 done) and Phase 2 (2 items) |
| `PHASE-1-PLAN.md` | Phase 1 Plan with 4 tasks (1 done) |
| `.git/` | Initialized git repo, clean working tree |

**Tests that use this fixture:** `TestMultipleSources` in `test_project_scenarios.py`

- `test_consolidation_needed` -- verifies `PlanConsolidator` detects the need for consolidation
- `test_multiple_sources_detected` -- verifies at least 3 planning sources are found
- `test_consolidation_works` -- copies fixture to a temp directory and runs consolidation, verifying success, output path, and item counts
- `test_after_consolidation_single_source` -- verifies that after consolidation only one planning source remains

**Claudetini behavior tested:** The plan consolidation workflow: detection of scattered planning files, merging them into a single source of truth, archiving originals, deduplicating items, and cleaning up stale files.

---

### 3.4 `04_completed_project`

**Description:** A project where every single roadmap item is marked as done.

**Project state it represents:** A finished project at 100% completion, with 3 milestones (Setup, Core, Release) and 9 items, all checked off.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Completed Project` with "All tasks done!" |
| `CLAUDE.md` | `# Project Guide` stub |
| `ROADMAP.md` | 3 milestones, 9 items, all `[x]` |
| `.git/` | Initialized git repo, clean working tree |

**Tests that use this fixture:** `TestCompletedProject` in `test_project_scenarios.py`

- `test_progress_is_100` -- verifies `done == total` and `total > 0`
- `test_all_milestones_complete` -- iterates every milestone and asserts all items have `done == True`

**Claudetini behavior tested:** Correct handling of the 100% completion boundary. The progress display, milestone status badges, and any "project complete" indicators should all trigger correctly.

---

### 3.5 `05_partial_progress`

**Description:** A project with mixed milestone completion states -- some fully done, some in progress, some not started.

**Project state it represents:** A typical mid-development project with 4 milestones and 13 items total. Milestone 1 (Foundation) is fully complete (3/3). Milestone 2 (Core Features) is partially done (2/4). Milestones 3 and 4 are untouched (0/3 each). Overall: 5/13 = 38%.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Partial Progress Project` |
| `CLAUDE.md` | `# Project Guide` stub |
| `ROADMAP.md` | 4 milestones, 13 items, 5 done |
| `src/__init__.py` | Empty init file |
| `src/main.py` | Simple `def main(): print('Hello')` |
| `.git/` | Initialized git repo, clean working tree |

**Tests that use this fixture:** `TestPartialProgress` in `test_project_scenarios.py`

- `test_progress_between_0_and_100` -- verifies the progress percentage is strictly between 0 and 100
- `test_first_milestone_complete` -- verifies all items in the first milestone are done

**Claudetini behavior tested:** Correct intermediate progress tracking, per-milestone completion status, and differentiation between complete, in-progress, and not-started milestones.

---

### 3.6 `06_no_git`

**Description:** A project directory that has never been initialized as a git repository.

**Project state it represents:** A project that exists on disk but has no version control. No `.git/` directory exists.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# No Git Project` with "Not a git repository." |
| `ROADMAP.md` | Phase 1 with 2 items, both unchecked |

**Tests that use this fixture:** `TestNoGit` in `test_project_scenarios.py`

- `test_project_loads` -- verifies `Project.from_path()` succeeds even without git
- `test_git_utils_handles_missing_repo` -- verifies `GitUtils` returns safe defaults (not exceptions) when `.git/` is absent
- `test_roadmap_still_works` -- verifies roadmap parsing functions independently of git

**Claudetini behavior tested:** Graceful degradation when git is unavailable. Claudetini should still load the project, parse roadmaps, and display planning data -- git-dependent features should simply return safe defaults rather than raising exceptions.

---

### 3.7 `07_dirty_git`

**Description:** A project with uncommitted modifications and untracked files in the working tree.

**Project state it represents:** A developer's working directory mid-edit. The `README.md` was modified after the initial commit, and two new files (`untracked.txt` and `src/new_file.py`) were added but never staged or committed.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | Modified after commit: now says "Modified but not committed." |
| `ROADMAP.md` | 2 items (1 done: "Initial setup", 1 todo: "Clean up") |
| `untracked.txt` | `This file is untracked` |
| `src/new_file.py` | `# New untracked file` |
| `.git/` | Initialized git repo, dirty working tree |

**Tests that use this fixture:** `TestDirtyGit` in `test_project_scenarios.py`

- `test_uncommitted_detected` -- verifies `GitUtils.uncommitted_files()` returns a non-empty list
- `test_untracked_detected` -- verifies that untracked files (like `untracked.txt`) appear in the uncommitted list

**Claudetini behavior tested:** Detection of uncommitted and untracked files for the project health dashboard. Claudetini uses this information to warn developers about unsaved work and to determine whether quality gates should block operations.

---

### 3.8 `08_quality_failures`

**Description:** A project containing source code with multiple deliberate quality violations.

**Project state it represents:** A codebase with lint errors, style violations, security issues, and failing tests -- designed to trigger every quality gate that Claudetini enforces.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Quality Failures Project` |
| `CLAUDE.md` | `# Project Guide` stub |
| `ROADMAP.md` | 4 items (1 done: "Setup", 3 todo: fix lint/type/test errors) |
| `src/__init__.py` | Empty init file |
| `src/bad_code.py` | Contains: multiple imports on one line, unused import (`unused_module`), missing type hints, PEP 8 spacing violations (`x,y,z`, `x==1`, `y+z`), bad class naming (`badlyNamedClass`), missing docstrings, hardcoded secret (`SECRET_KEY`), TODO comment |
| `tests/__init__.py` | Empty init file |
| `tests/test_main.py` | Two tests that always fail: `assert 1 == 2` and `raise Exception` |
| `.git/` | Initialized git repo, clean working tree |

**Tests that use this fixture:** `TestQualityFailures` in `test_project_scenarios.py`

- `test_health_scan_detects_issues` -- verifies `HealthScanner.scan_all()` returns at least one non-passing result

**Claudetini behavior tested:** The health scanning and quality gate system. This fixture validates that `HealthScanner` correctly identifies lint violations, security issues (hardcoded secrets), failing tests, and style problems. It also exercises the `secrets_scanner` module's detection of hardcoded credentials.

---

### 3.9 `09_large_roadmap`

**Description:** A project with a very large roadmap containing many milestones and items, designed to stress-test the parser.

**Project state it represents:** An enterprise-scale project plan with 10 milestones, each containing 15 items (150 total). Milestones 1-6 are fully complete (90 items), Milestone 7 is partially complete (7/15), and Milestones 8-10 are entirely incomplete. Overall: 97/150 = 64%.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Large Roadmap Project` |
| `CLAUDE.md` | `# Project Guide` stub |
| `ROADMAP.md` | 10 milestones, 150 items, 97 done (6,078 bytes) |
| `.git/` | Initialized git repo, clean working tree |

**Tests that use this fixture:** `TestLargeRoadmap` in `test_project_scenarios.py`

- `test_handles_large_roadmap` -- verifies the parser handles 100+ items without errors
- `test_progress_calculation_accurate` -- verifies the calculated percentage falls between 55% and 65% (expected: ~64%)

**Claudetini behavior tested:** Performance and correctness at scale. Ensures the roadmap parser, plan scanner, and progress calculator all handle large input without truncation, memory issues, or accuracy drift.

---

### 3.10 `10_already_consolidated`

**Description:** A project that has already been through the consolidation process, with a single roadmap at `.claude/planning/ROADMAP.md` and an archive of the original.

**Project state it represents:** The ideal end-state after a Claudetini consolidation run. The roadmap lives in the canonical `.claude/planning/` location, a timestamped archive preserves the pre-consolidation roadmap, and the `CLAUDE.md` references the consolidated location.

**Key files:**

| File | Contents |
|------|----------|
| `README.md` | `# Consolidated Project` |
| `CLAUDE.md` | References `.claude/planning/` as single source of truth |
| `.claude/planning/ROADMAP.md` | Consolidated roadmap with timestamp, 3 milestones, 10 items (5 done = 50%) |
| `.claude/planning/archive/20240115_103000/ROADMAP.md` | Pre-consolidation roadmap archive |
| `.git/` | Initialized git repo, clean working tree |

**Tests that use this fixture:** `TestAlreadyConsolidated` in `test_project_scenarios.py`

- `test_uses_consolidated_path` -- verifies the detected roadmap path includes `.claude/planning`
- `test_no_consolidation_needed` -- verifies the consolidator either finds only 1 source or reports no consolidation needed
- `test_single_source_in_scan` -- verifies the plan scanner finds exactly 1 source

**Claudetini behavior tested:** Idempotency of the consolidation process. Once a project has been consolidated, Claudetini must recognize it as already clean, locate the roadmap in `.claude/planning/`, and not attempt to re-consolidate. Also verifies that the archive directory does not confuse the scanner into counting it as a second source.

---

## 4. How to Create New Fixtures

### Regenerating existing fixtures

To regenerate all 10 fixtures from scratch:

```bash
python tests/fixtures/generate_fixtures.py
```

This deletes and recreates the entire `tests/fixtures/projects/` directory and regenerates `manifest.json`.

### Adding a new fixture

1. **Edit `tests/fixtures/generate_fixtures.py`:**
   - Add a new setup function following the naming convention `setup_<fixture_name>(path: Path) -> None`.
   - Include a docstring -- it becomes the `description` field in `manifest.json`.
   - Initialize git if appropriate (`run_git(path, "init")` plus user config).
   - Create the files that define the project state.
   - Commit if using git.

2. **Register the fixture** in the `FIXTURES` list at the bottom of the generator script, following the numbering convention:

   ```python
   FIXTURES = [
       ...
       ("11_new_fixture", setup_new_fixture),
   ]
   ```

3. **Add corresponding test class** in `tests/e2e/test_project_scenarios.py`:

   ```python
   class TestNewFixture:
       """Tests for the new fixture scenario."""

       @pytest.fixture
       def project_path(self) -> Path:
           return FIXTURES_DIR / "11_new_fixture"

       def test_expected_behavior(self, project_path):
           if not project_path.exists():
               pytest.skip("Fixture not generated")
           # ... assertions ...
   ```

4. **Regenerate** by running the generator script.

5. **Update this document** with the new fixture's catalog entry.

### Conventions for fixture setup functions

- Always accept `path: Path` as the only parameter.
- Always include a docstring (used for manifest descriptions).
- Use `run_git()` helper for git commands.
- Use `pathlib` for file creation: `(path / "filename").write_text(...)`.
- Set git user config in every fixture that uses git (prevents CI failures).
- Keep fixtures minimal -- include only the files needed to test the scenario.

---

## 5. Important Notes

### These are NOT demo projects

The fixture projects exist solely for automated testing. They are not example applications, tutorials, or templates. Do not reference them as usage examples in user-facing documentation.

### Do not modify fixture files directly

All fixture content is generated by `tests/fixtures/generate_fixtures.py`. If you edit a fixture file by hand, your changes will be lost the next time the generator runs. Always modify the generator script instead and regenerate.

### Do not add fixtures to .gitignore

The fixtures (including their `.git/` directories) are committed to the repository so that tests work immediately after cloning without running the generator. The generator script is provided for recreation and for adding new fixtures.

### Fixture `.git/` directories

Each fixture with git has its own embedded `.git/` directory. These are real git repositories (not bare repos) with actual commit history, which allows `GitUtils` and other git-dependent code to operate on them identically to real projects. Be aware that tools like `git` itself may get confused if you run commands from within the fixture directories, since they are nested inside the main Claudetini repo.

### Do not modify files in `~/.claude/`

As noted in the project's `CLAUDE.md`, Claudetini is read-only for Claude Code data. The test fixtures do not touch `~/.claude/` at all -- they are self-contained project directories with no external dependencies.

---

## 6. Relationship to Core Module Tests

The test fixtures complement but do not replace the unit tests for individual core modules. Here is how they relate:

| Layer | Location | Approach | Fixtures used? |
|-------|----------|----------|----------------|
| **Unit tests** | `tests/test_roadmap.py`, `tests/test_plan_scanner.py`, `tests/test_git_utils.py`, etc. | Create temporary directories and mock data inline using `tmp_path` and pytest fixtures | No -- they create their own test data |
| **E2E scenario tests** | `tests/e2e/test_project_scenarios.py` | Run real core module code against pre-built project directories | Yes -- all 10 fixtures |
| **Integration tests** | `TestIntegration` class in `test_project_scenarios.py` | Verify that all fixtures load without crashing | Yes -- iterates all fixtures |

The unit tests in `tests/test_roadmap.py`, `tests/test_plan_scanner.py`, `tests/test_git_utils.py`, and others use inline `tmp_path` directories with hand-crafted content. They test individual functions in isolation with precise input control.

The E2E scenario tests exercise the same core modules (`Project`, `RoadmapParser`, `ProjectPlanScanner`, `PlanConsolidator`, `GitUtils`, `HealthScanner`) against the fixture projects, which represent more realistic and complete project states. This catches integration issues that unit tests may miss, such as:

- File discovery across nested directories
- Interaction between multiple planning files
- Git state detection in real repositories
- The full consolidation workflow (detect, merge, archive, clean)
- Correct behavior at boundary conditions (0%, 100%, 150+ items, no git)

Together, the unit tests and fixture-based E2E tests provide layered coverage of Claudetini's core logic.
