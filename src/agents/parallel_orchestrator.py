"""Parallel agent execution engine — AI-orchestrated phased execution.

Processes an ExecutionPlan generated by the PlanningAgent:
- Sequential phases: one agent at a time in a single worktree
- Parallel phases: N agents in separate worktrees, all running simultaneously
- Merges branches after each phase
- Runs verification at the end
"""

from __future__ import annotations

import asyncio
import logging
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Literal

from ..core.worktree_manager import WorktreeManager
from .planning_agent import ExecutionPlan

logger = logging.getLogger(__name__)


@dataclass
class AgentSlot:
    """State for a single agent in a parallel batch."""

    task_index: int
    task_text: str
    prompt: str
    worktree_path: Path | None = None  # Assigned during execution
    branch: str = ""
    group_id: int = 0       # Agent assignment ID
    phase_id: int = 0       # Which execution phase
    status: Literal["pending", "running", "succeeded", "failed", "cancelled"] = "pending"
    output_file: Path | None = None
    started_at: datetime | None = None
    finished_at: datetime | None = None
    error: str | None = None
    cost_estimate: float = 0.0


@dataclass
class MergeResult:
    """Outcome of merging a single branch."""

    branch: str
    success: bool
    conflict_files: list[str] = field(default_factory=list)
    resolution_method: str = "clean"
    message: str = ""


@dataclass
class ParallelBatchStatus:
    """Aggregate status for a parallel execution batch."""

    batch_id: str
    phase: str = "idle"
    current_phase_id: int = 0
    current_phase_name: str = ""
    agents: list[AgentSlot] = field(default_factory=list)
    merge_results: list[MergeResult] = field(default_factory=list)
    verification: dict | None = None
    verification_output_file: Path | None = None
    finalize_message: str | None = None
    plan_summary: str = ""
    total_cost: float = 0.0
    started_at: datetime | None = None
    finished_at: datetime | None = None
    error: str | None = None


class ParallelOrchestrator:
    """Coordinate phased parallel agent dispatch, merge, and verification."""

    def __init__(self, project_path: Path) -> None:
        self.project_path = project_path.resolve()
        self._batches: dict[str, ParallelBatchStatus] = {}
        self._cancel_flags: dict[str, bool] = {}

    async def execute_plan(
        self,
        batch_id: str,
        tasks: list[dict],
        plan: ExecutionPlan,
        max_parallel: int = 3,
    ) -> ParallelBatchStatus:
        """Execute a phased plan with worktree-based parallel agents.

        Each ExecutionPhase is processed in order:
        - Sequential phase (parallel=false): tasks in a single worktree
        - Parallel phase (parallel=true): N agents, each in its own worktree

        Args:
            batch_id: Unique identifier for this batch.
            tasks: Original task list with 'text' and optional 'prompt'.
            plan: AI-generated ExecutionPlan.
            max_parallel: Maximum concurrent agents.
        """
        wm = WorktreeManager(self.project_path)
        status = ParallelBatchStatus(
            batch_id=batch_id,
            phase="validating",
            plan_summary=plan.summary,
            started_at=datetime.now(),
        )
        self._batches[batch_id] = status
        self._cancel_flags[batch_id] = False

        # Build all agent slots up front for status tracking
        all_agents = self._build_agent_slots(tasks, plan)
        status.agents = all_agents

        original_branch = wm.get_current_branch()
        base_sha = wm.get_head_sha()

        # Write HMR lock file so Vite suppresses hot-reload during merges.
        hmr_lock = self.project_path / "app" / ".parallel-running"
        try:
            hmr_lock.write_text(batch_id)
        except OSError:
            pass

        try:
            # Validate clean tree
            if not wm.is_working_tree_clean():
                dirty = wm.get_dirty_files()
                file_list = ", ".join(dirty[:5])
                extra = f" (+{len(dirty) - 5} more)" if len(dirty) > 5 else ""
                status.phase = "failed"
                status.error = f"Working tree has {len(dirty)} uncommitted change(s): {file_list}{extra}. Commit or stash before parallel execution."
                status.finished_at = datetime.now()
                return status

            # Process phases sequentially
            status.phase = "executing"

            for phase in plan.phases:
                if self._cancel_flags.get(batch_id):
                    break

                status.current_phase_id = phase.phase_id
                status.current_phase_name = phase.name

                if phase.parallel and len(phase.agents) > 1:
                    # Parallel phase: one worktree per agent
                    await self._execute_parallel_phase(
                        batch_id, phase, wm, base_sha, original_branch,
                        all_agents, max_parallel, status,
                    )
                else:
                    # Sequential phase: single worktree for all agents
                    await self._execute_sequential_phase(
                        batch_id, phase, wm, base_sha, original_branch,
                        all_agents, status,
                    )

                if self._cancel_flags.get(batch_id):
                    break

                # Update base_sha for next phase
                base_sha = wm.get_head_sha()

            # Calculate total cost
            status.total_cost = sum(a.cost_estimate for a in all_agents)

            if self._cancel_flags.get(batch_id):
                status.phase = "cancelled"
                status.error = "Cancelled by user"
            elif any(not mr.success for mr in status.merge_results):
                status.phase = "complete"
                status.error = "Some merges had conflicts"
            else:
                # Verification
                status.phase = "verifying"
                try:
                    from .dispatcher import get_dispatch_output_path
                    from .planning_agent import PlanningAgent

                    _sid, verify_output = get_dispatch_output_path(self.project_path)
                    status.verification_output_file = verify_output

                    # Build agent status summaries for the verification agent
                    agent_status_data = [
                        {
                            "task_text": slot.task_text,
                            "status": slot.status,
                            "error": slot.error,
                            "group_id": slot.group_id,
                            "phase_id": slot.phase_id,
                        }
                        for slot in all_agents
                    ]

                    loop = asyncio.get_event_loop()
                    agent = PlanningAgent(self.project_path)
                    vr = await loop.run_in_executor(
                        None,
                        lambda: agent.verify_completion(
                            tasks, plan,
                            output_file=verify_output,
                            agent_statuses=agent_status_data,
                        ),
                    )
                    status.verification = {
                        "overall_pass": vr.overall_pass,
                        "criteria_results": [
                            {
                                "criterion": cr.criterion,
                                "passed": cr.passed,
                                "evidence": cr.evidence,
                                "notes": cr.notes,
                            }
                            for cr in vr.criteria_results
                        ],
                        "summary": vr.summary,
                    }
                except Exception as exc:
                    logger.warning("Verification failed for batch %s: %s", batch_id, exc)
                    status.verification = {
                        "overall_pass": False,
                        "criteria_results": [],
                        "summary": str(exc),
                    }

                # Finalizing — mark roadmap items, stage everything, commit
                status.phase = "finalizing"
                finalize_parts: list[str] = []

                # Mark roadmap items complete based on agent success.
                # Verification results are informational — if an agent
                # succeeded (code committed + merged), the task is done.
                # Lint/type errors are noted but don't block completion.
                succeeded_texts = [
                    slot.task_text
                    for slot in all_agents
                    if slot.status == "succeeded"
                ]
                if succeeded_texts:
                    try:
                        from ..core.roadmap import RoadmapParser

                        roadmap = RoadmapParser.parse(self.project_path)
                        if roadmap is not None:
                            marked = roadmap.bulk_mark_complete(succeeded_texts)
                            if marked > 0:
                                roadmap.save()
                                finalize_parts.append(f"marked {marked} item(s) complete")
                    except Exception as exc:
                        logger.warning("Failed to update roadmap: %s", exc)

                    # Add verification status as informational note
                    verification_passed = (
                        status.verification
                        and status.verification.get("overall_pass", False)
                    )
                    if not verification_passed and status.verification:
                        failed_criteria = [
                            c.get("criterion", "unknown")
                            for c in status.verification.get("criteria_results", [])
                            if not c.get("passed", True)
                        ]
                        if failed_criteria:
                            finalize_parts.append(
                                f"verification noted {len(failed_criteria)} issue(s)"
                            )

                # Stage ONLY the roadmap file — agent work is already merged.
                # Using stage_all() here would sweep in unrelated untracked files.
                try:
                    roadmap_path = self.project_path / ".claude" / "planning" / "ROADMAP.md"
                    if roadmap_path.exists():
                        wm.stage_files([str(roadmap_path)])
                    # Check if there are staged changes (exit code 1 = diffs exist)
                    diff_out, diff_code = wm._run_git("diff", "--cached", "--quiet")
                    if diff_code != 0:
                        num_agents = plan.estimated_total_agents
                        title = status.plan_summary or "parallel tasks"
                        msg = f"feat(parallel): {title} — {len(tasks)} tasks via {num_agents} agents"
                        success, sha = wm.commit(msg)
                        if success:
                            finalize_parts.append(f"committed as {sha[:8]}")
                        else:
                            finalize_parts.append(f"commit failed: {sha}")
                    else:
                        finalize_parts.append("no additional changes to commit")
                except Exception as exc:
                    finalize_parts.append(f"commit error: {exc}")

                status.finalize_message = ", ".join(finalize_parts).capitalize() if finalize_parts else None

                status.phase = "complete"

        except Exception as exc:
            logger.exception("Parallel batch %s failed", batch_id)
            status.phase = "failed"
            status.error = str(exc)
        finally:
            # NOTE: Do NOT remove hmr_lock here. The frontend removes it
            # when the user closes the overlay, preventing a Vite reload
            # from disrupting the results view.
            try:
                wm.cleanup_batch(batch_id)
            except Exception as exc:
                logger.warning("Worktree cleanup failed for batch %s: %s", batch_id, exc)
            status.finished_at = datetime.now()

        return status

    async def _execute_parallel_phase(
        self,
        batch_id: str,
        phase,
        wm: WorktreeManager,
        base_sha: str,
        original_branch: str,
        all_agents: list[AgentSlot],
        max_parallel: int,
        status: ParallelBatchStatus,
    ) -> None:
        """Execute a parallel phase: multiple agents in separate worktrees."""
        worktrees = {}
        for agent_assign in phase.agents:
            if self._cancel_flags.get(batch_id):
                break
            try:
                wt = wm.create_worktree(
                    batch_id, agent_assign.agent_id, base_ref=base_sha
                )
                worktrees[agent_assign.agent_id] = wt
            except RuntimeError as exc:
                logger.error(
                    "Failed to create worktree for agent %d: %s",
                    agent_assign.agent_id, exc,
                )
                # Mark all agents in this assignment as failed
                for slot in all_agents:
                    if slot.group_id == agent_assign.agent_id and slot.phase_id == phase.phase_id:
                        slot.status = "failed"
                        slot.error = f"Worktree creation failed: {exc}"
                continue

        if self._cancel_flags.get(batch_id):
            return

        # Run all agents in parallel
        sem = asyncio.Semaphore(max_parallel)
        await asyncio.gather(
            *[
                self._run_agent_queue(
                    batch_id, agent_assign,
                    worktrees.get(agent_assign.agent_id),
                    all_agents, sem,
                )
                for agent_assign in phase.agents
                if agent_assign.agent_id in worktrees
            ],
            return_exceptions=True,
        )

        # Merge phase: merge each agent's branch
        status.phase = "merging"
        for agent_assign in phase.agents:
            wt = worktrees.get(agent_assign.agent_id)
            if not wt:
                continue

            # Remove worktree first (git requires it before merging)
            wm.remove_worktree(wt.path, force=True)

            success, msg, conflicts = wm.merge_branch(wt.branch, into=original_branch)
            resolution = "clean" if success else ("conflict" if conflicts else "failed")
            status.merge_results.append(
                MergeResult(
                    branch=wt.branch,
                    success=success,
                    conflict_files=conflicts,
                    resolution_method=resolution,
                    message=msg,
                )
            )
            wm.delete_branch(wt.branch)

            if not success:
                logger.warning(
                    "Merge failed for branch %s: %s (conflicts: %s)",
                    wt.branch, msg, conflicts,
                )

        status.phase = "executing"

    async def _execute_sequential_phase(
        self,
        batch_id: str,
        phase,
        wm: WorktreeManager,
        base_sha: str,
        original_branch: str,
        all_agents: list[AgentSlot],
        status: ParallelBatchStatus,
    ) -> None:
        """Execute a sequential phase: agents run one by one in a single worktree."""
        try:
            wt = wm.create_worktree(
                batch_id, phase.phase_id * 100, base_ref=base_sha
            )
        except RuntimeError as exc:
            logger.error("Failed to create worktree for phase %d: %s", phase.phase_id, exc)
            for agent_assign in phase.agents:
                for slot in all_agents:
                    if slot.group_id == agent_assign.agent_id and slot.phase_id == phase.phase_id:
                        slot.status = "failed"
                        slot.error = f"Worktree creation failed: {exc}"
            return

        for agent_assign in phase.agents:
            if self._cancel_flags.get(batch_id):
                break
            await self._run_agent_queue(
                batch_id, agent_assign, wt, all_agents, sem=None
            )

        # Merge the sequential worktree
        wm.remove_worktree(wt.path, force=True)
        success, msg, conflicts = wm.merge_branch(wt.branch, into=original_branch)
        resolution = "clean" if success else ("conflict" if conflicts else "failed")
        status.merge_results.append(
            MergeResult(
                branch=wt.branch,
                success=success,
                conflict_files=conflicts,
                resolution_method=resolution,
                message=msg,
            )
        )
        wm.delete_branch(wt.branch)

    async def _run_agent_queue(
        self,
        batch_id: str,
        agent_assign,
        worktree,
        all_agents: list[AgentSlot],
        sem: asyncio.Semaphore | None,
    ) -> None:
        """Run an agent's task queue sequentially in its worktree.

        Each task in the agent's task_indices list is dispatched one by one.
        The agent_prompt from the planning agent is used as the dispatch prompt.
        """
        if worktree is None:
            return

        # Find all slots belonging to this agent assignment
        agent_slots = [
            s for s in all_agents
            if s.group_id == agent_assign.agent_id
            and s.phase_id in (
                # Match by checking all phases this agent could be in
                getattr(agent_assign, '_phase_id', s.phase_id),
            )
        ]

        # The planning agent provides a single combined prompt for the agent.
        # We dispatch it once with the full agent_prompt.
        # However, we track individual task slots for status.

        # Store theme on slots for commit messages
        theme = getattr(agent_assign, 'theme', '')
        for slot in agent_slots:
            slot._agent_theme = theme  # type: ignore[attr-defined]

        # Mark all slots as running
        for slot in agent_slots:
            slot.worktree_path = worktree.path
            slot.branch = worktree.branch

        async def _dispatch():
            # Use the combined agent_prompt for dispatch
            prompt = agent_assign.agent_prompt
            if not prompt:
                # Fallback: combine individual task texts
                prompt = "\n\n".join(
                    f"Task {idx + 1}: {all_agents[idx].task_text if idx < len(all_agents) else ''}"
                    for idx in agent_assign.task_indices
                )

            # Add constraint to prevent agents from modifying unrelated files
            prompt += "\n\nIMPORTANT CONSTRAINTS:\n"
            prompt += "- ONLY modify files directly related to your assigned tasks above.\n"
            prompt += "- Do NOT modify unrelated files (README, CONTRIBUTING, CHANGELOG, etc.).\n"
            prompt += "- Do NOT refactor or 'improve' existing code that is not part of your tasks.\n"

            # Mark first slot as running
            if agent_slots:
                agent_slots[0].status = "running"
                agent_slots[0].started_at = datetime.now()

            await self._run_single_dispatch(
                agent_slots, prompt, worktree.path, batch_id
            )

        if sem is not None:
            async with sem:
                if self._cancel_flags.get(batch_id):
                    for slot in agent_slots:
                        slot.status = "cancelled"
                    return
                await _dispatch()
        else:
            if self._cancel_flags.get(batch_id):
                for slot in agent_slots:
                    slot.status = "cancelled"
                return
            await _dispatch()

    async def _run_single_dispatch(
        self,
        agent_slots: list[AgentSlot],
        prompt: str,
        worktree_path: Path,
        batch_id: str,
        max_retries: int = 2,
    ) -> None:
        """Dispatch a single agent with its combined prompt, retrying on failure."""
        from .dispatcher import dispatch_task, get_dispatch_output_path

        # Build system prompt for project context
        system_prompt_file = self._build_system_prompt()

        try:
            _session_id, output_file = get_dispatch_output_path(worktree_path)

            # Set output file on all slots for monitoring
            for slot in agent_slots:
                slot.output_file = output_file
                slot.status = "running"
                if not slot.started_at:
                    slot.started_at = datetime.now()

            last_error = ""

            for attempt in range(max_retries + 1):
                if self._cancel_flags.get(batch_id):
                    for slot in agent_slots:
                        slot.status = "cancelled"
                    return

                # Run dispatch in a thread to avoid blocking the event loop
                loop = asyncio.get_event_loop()
                result = await loop.run_in_executor(
                    None,
                    lambda: dispatch_task(
                        prompt=prompt,
                        working_dir=worktree_path,
                        output_file=output_file,
                        system_prompt_file=system_prompt_file,
                    ),
                )

                if result.success:
                    # CRITICAL: Commit the agent's work inside the worktree.
                    committed = self._commit_worktree_changes(
                        worktree_path, batch_id,
                        theme=getattr(agent_slots[0], '_agent_theme', None),
                    )
                    if committed:
                        # Run auto-fix linting before merge
                        self._run_pre_merge_lint(worktree_path, batch_id)
                        now = datetime.now()
                        for slot in agent_slots:
                            slot.status = "succeeded"
                            slot.finished_at = now
                        return
                    elif attempt == 0 and self._worktree_has_expected_content(worktree_path, prompt):
                        # Content already exists (e.g., files were pre-populated).
                        # Mark as succeeded without retrying — saves API credits.
                        logger.info("Agent produced no changes but expected content exists. Marking as already complete.")
                        now = datetime.now()
                        for slot in agent_slots:
                            slot.status = "succeeded"
                            slot.finished_at = now
                        return
                    else:
                        last_error = "Agent completed but produced no file changes"
                else:
                    if result.token_limit_reached:
                        # Don't retry token limits
                        last_error = result.error_message or "Token limit reached"
                        break
                    last_error = result.error_message or "Unknown dispatch error"

                if attempt < max_retries:
                    logger.warning(
                        "Agent attempt %d/%d failed: %s. Retrying...",
                        attempt + 1, max_retries + 1, last_error,
                    )
                    self._reset_worktree(worktree_path)

            # All attempts exhausted
            now = datetime.now()
            for slot in agent_slots:
                slot.status = "failed"
                slot.error = f"Failed after {max_retries + 1} attempts: {last_error}"
                slot.finished_at = now

        except Exception as exc:
            now = datetime.now()
            for slot in agent_slots:
                slot.status = "failed"
                slot.error = str(exc)
                slot.finished_at = now
            logger.error("Agent dispatch failed: %s", exc)

    def _build_system_prompt(self) -> Path | None:
        """Build a system prompt file for agent context."""
        try:
            from ..core.project import Project
            from ..core.system_prompt import SystemPromptBuilder

            project = Project.from_path(self.project_path)
            builder = SystemPromptBuilder(project, blitz_mode=True)
            return builder.build_and_write()
        except Exception as exc:
            logger.debug("System prompt generation failed: %s", exc)
            return None

    @staticmethod
    def _worktree_has_expected_content(worktree_path: Path, prompt: str) -> bool:
        """Check if the worktree already has files mentioned in the prompt.

        When an agent produces no changes but the files already exist with content,
        the task is likely already complete (e.g., from a previous run or manual edit).
        This avoids wasting retries on idempotent tasks.
        """
        import re

        # Extract file paths mentioned in the prompt
        # Common patterns: "Create `path/to/file.py`", "modify `path/to/file.ts`"
        file_refs = re.findall(r'`([a-zA-Z0-9_/.-]+\.\w+)`', prompt)
        if not file_refs:
            return False

        # Check if at least half the referenced files exist in the worktree
        found = 0
        for ref in file_refs:
            candidate = worktree_path / ref
            if candidate.exists() and candidate.stat().st_size > 0:
                found += 1

        # If most referenced files already exist with content, task is likely done
        return found > 0 and found >= len(file_refs) * 0.5

    @staticmethod
    def _run_pre_merge_lint(worktree_path: Path, batch_id: str) -> None:
        """Run ruff check --fix on changed Python files, then amend the commit.

        This catches lint issues that agents couldn't fix due to sandbox
        restrictions. Only touches files the agent modified.
        """
        import subprocess

        def _git(*args: str) -> tuple[str, int]:
            try:
                r = subprocess.run(
                    ["git", *args], cwd=worktree_path,
                    capture_output=True, text=True, timeout=30,
                )
                return r.stdout.rstrip("\n"), r.returncode
            except (subprocess.TimeoutExpired, FileNotFoundError):
                return "", 1

        # Get list of changed Python files in the last commit
        diff_out, code = _git("diff", "--name-only", "HEAD~1", "HEAD")
        if code != 0:
            return

        py_files = [
            f for f in diff_out.split("\n")
            if f.strip() and f.endswith(".py")
        ]
        if not py_files:
            return

        # Run ruff check --fix (best-effort, ignore failures)
        abs_files = [str(worktree_path / f) for f in py_files]
        try:
            subprocess.run(
                ["ruff", "check", "--fix", "--quiet", *abs_files],
                cwd=worktree_path, capture_output=True, timeout=30,
            )
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return

        # If ruff made changes, amend the commit
        _, diff_code = _git("diff", "--quiet")
        if diff_code != 0:
            _git("add", "-A")
            _git("commit", "--amend", "--no-edit")
            logger.info("Pre-merge lint fixed issues in %d file(s)", len(py_files))

    @staticmethod
    def _reset_worktree(worktree_path: Path) -> None:
        """Reset a worktree to clean state for retry."""
        import subprocess

        subprocess.run(
            ["git", "checkout", "--", "."],
            cwd=worktree_path,
            capture_output=True,
            timeout=30,
        )
        subprocess.run(
            ["git", "clean", "-fd"],
            cwd=worktree_path,
            capture_output=True,
            timeout=30,
        )

    @staticmethod
    def _commit_worktree_changes(
        worktree_path: Path,
        batch_id: str,
        theme: str | None = None,
    ) -> bool:
        """Stage and commit all changes in a worktree after agent dispatch.

        Returns True if a commit was created (files were changed),
        False if the agent produced no changes.
        """
        import subprocess

        def _run(*args: str) -> tuple[str, int]:
            try:
                r = subprocess.run(
                    ["git", *args],
                    cwd=worktree_path,
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                return r.stdout.rstrip("\n"), r.returncode
            except (subprocess.TimeoutExpired, FileNotFoundError):
                return "", 1

        # Stage all new and modified files
        _, code = _run("add", "-A")
        if code != 0:
            logger.warning("git add failed in worktree %s", worktree_path)
            return False

        # Check if there are staged changes
        _, diff_code = _run("diff", "--cached", "--quiet")
        if diff_code == 0:
            # No changes staged — agent wrote nothing
            return False

        # Commit with descriptive message including agent theme
        theme_label = f" [{theme}]" if theme else ""
        _, commit_code = _run(
            "commit", "-m", f"Agent work{theme_label} for batch {batch_id}",
        )
        if commit_code != 0:
            logger.warning("git commit failed in worktree %s", worktree_path)
            return False

        return True

    def _build_agent_slots(
        self, tasks: list[dict], plan: ExecutionPlan
    ) -> list[AgentSlot]:
        """Pre-build all AgentSlots from the plan for status tracking."""
        slots: list[AgentSlot] = []
        seen_indices: set[int] = set()

        for phase in plan.phases:
            for agent_assign in phase.agents:
                # Store phase_id on the agent_assign for matching later
                agent_assign._phase_id = phase.phase_id  # type: ignore[attr-defined]

                for task_idx in agent_assign.task_indices:
                    if task_idx in seen_indices:
                        continue
                    seen_indices.add(task_idx)

                    text = tasks[task_idx].get("text", "") if task_idx < len(tasks) else f"Task {task_idx}"
                    prompt = tasks[task_idx].get("prompt", text) if task_idx < len(tasks) else text

                    slots.append(
                        AgentSlot(
                            task_index=task_idx,
                            task_text=text,
                            prompt=prompt,
                            group_id=agent_assign.agent_id,
                            phase_id=phase.phase_id,
                        )
                    )

        return slots

    def get_status(self, batch_id: str) -> ParallelBatchStatus | None:
        """Get the current status of a batch."""
        return self._batches.get(batch_id)

    def cancel_batch(self, batch_id: str) -> bool:
        """Request cancellation of a running batch."""
        if batch_id in self._batches:
            self._cancel_flags[batch_id] = True
            return True
        return False

    @staticmethod
    def generate_batch_id() -> str:
        """Generate a unique batch ID."""
        return f"par-{datetime.now().strftime('%Y%m%d%H%M%S')}-{uuid.uuid4().hex[:8]}"
